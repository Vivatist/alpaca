# PDF Parser – актуальный процесс

`app/parsers/pdf_parser_module/pdf_parser.py` теперь содержит объединённую реализацию
«старого» и «optimized» парсера. Файл возвращает **plain текст (Markdown)**, а не
сложные структуры с YAML – вся упаковка происходит позже в ingest-пайплайне.

## 1. Первичная подготовка

1. Проверяем существование файла, логируем старт.
2. Извлекаем метаданные через `extract_pdf_metadata()` (PyMuPDF + pypdf):
     - количество страниц, шифрование, размеры.
3. При необходимости выполняем `smart_rotate_pdf()` – автоповорот страниц во временный
     файл (например, если документ сфотографирован боком). Временный файл удаляется
     после завершения парсинга.

## 2. Определение типа документа

```
_detect_document_type():
        - открывает первую страницу via PyMuPDF
        - если текста >200 символов → "text"
        - если текста <50 и есть изображения → "scanned"
        - иначе → "hybrid"
```

Эвристика быстрая и не требует полного чтения файла.

## 3. Основные стратегии

- **Text**: `_parse_text()`
    1. `Unstructured`/`partition_pdf` (strategy=hi_res, rus-only). Если результат короткий
        или выглядит как «буквы через пробел», храним как запасной вариант и идём дальше.
    2. `MarkItDown`
    3. `PyMuPDF` (page.get_text()) – финальный fallback для текстовых файлов.

  Каждая стратегия оценивается эвристикой качества: слишком короткий текст или высокая доля
  односимвольных токенов считается невалидным, поэтому парсер автоматически пытается другие
  источники перед тем как вернуть результат.

- **Scanned**: `_parse_scanned()`
    1. Если доступна пара `pdf2image` + `pytesseract`, прогоняем страницы через локальный
        OCR (`lang='rus+eng'`, `--psm 6`). Собираем результат по страницам, вычисляем долю
        кириллицы для логов и проверяем качество, как в текстовом сценарии.
    2. Если локального OCR нет или результат плохой – используем `Unstructured` с `strategy='hi_res'`.

- **Hybrid**: `_parse_hybrid()`
    1. Пробуем текстовый сценарий.
    2. При недостатке контента (<100 символов) дополнительно запускаем OCR сценарий.

## 4. Fallback цепочка

Если после вышеописанных шагов текст пустой, запускается `_parse_fallback()` (pypdf),
который просто объединяет `page.extract_text()`. Это последняя линия обороны.

## 5. Сетевые вызовы (Unstructured)

```
POST /general/v0/general
json = {
        strategy: 'hi_res',
        languages: 'rus',
        pdf_infer_table_structure: 'true'
}
```

Ответ → список элементов (Title, NarrativeText, Table…). Мы отбрасываем картинки и
пустые блоки, а короткий первый `Title` превращаем в `# Heading`. Всё остальное просто
склеивается через пустую строку.

## 6. Возврат значения

- Парсер возвращает `str` (Markdown/текст). Пустая строка сигнализирует об ошибке,
    и ingest-пайплайн переводит файл в `status_sync=error`.
- Временный файл, созданный `smart_rotate_pdf`, удаляется в `finally`.

## 7. Зависимости и деградация

| Компонент                      | Назначение                     | Поведение при недоступности |
|--------------------------------|--------------------------------|-----------------------------|
| PyMuPDF (fitz)                 | Быстрый анализ + текстовый fallback | Без него `hybrid` по дефолту |
| MarkItDown                     | Основной парсер структуры      | Пропускается, идём дальше   |
| Unstructured API               | OCR/гибридная обработка        | Пропускаем, пробуем локальные методы |
| pdf2image + pytesseract        | Локальный OCR                  | Переходим напрямую к Unstructured |
| pypdf                          | Самый последний fallback       | Ошибка → возвращаем пустую строку |

## 8. Производительность

- Текстовые PDF: 0.5–1.5 с (MarkItDown или PyMuPDF).
- Сканированные: 2–6 с на страницу (локальный OCR) или зависит от Unstructured.
- Smart rotation добавляет ещё ~0.1–0.3 с на документ.

## 9. Будущие доработки

- Добавить кэширование результата `_detect_document_type` для нескольких страниц.
- Сохранять метаданные (pages, is_scanned) в YAML, когда ingestion слой будет готов
    принимать эти значения.
- Рассмотреть объединение локального OCR и unstructured-результатов (например,
    постраничное слияние).

Документ описывает реальное текущее поведение `PDFParser` и может использоваться
как reference для разработчиков и инженеров сопровождения.
